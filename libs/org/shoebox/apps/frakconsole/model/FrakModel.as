/**  HomeMade by shoe[box]   Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are  met:  * Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.    * Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.    * Neither the name of shoe[box] nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.*/package org.shoebox.apps.frakconsole.model {	import flash.events.IEventDispatcher;	import org.shoebox.collections.HashMap;	import org.shoebox.apps.frakconsole.commands.StackCommand;	import org.shoebox.apps.frakconsole.views.FrakView;	import org.shoebox.events.LoggerEvent;	import org.shoebox.patterns.commands.AbstractCommand;	import org.shoebox.patterns.factory.Factory;	import org.shoebox.patterns.mvc.abstracts.AModel;	import org.shoebox.patterns.mvc.interfaces.IModel;	import org.shoebox.tools.Perf;	import org.shoebox.utils.logger.Logger;	import flash.events.Event;	import flash.system.Capabilities;	import flash.system.System;	import flash.utils.Dictionary;	import flash.utils.getQualifiedClassName;	import flash.utils.getQualifiedSuperclassName;	/**	 * Frak console application model	*  	* org.shoebox.apps.frakconsole.model.FrakModel	* @author shoebox	*/	public class FrakModel extends AModel implements IModel{				protected var _dCOMMANDS_CUSTOM	: Dictionary;		protected var _dCOMMANDS		: Dictionary;		protected var _dVARS			: Dictionary;		protected var _dVARS_CUSTOM		: Dictionary;		protected var _oPERF			: Perf;		protected var _sABSTRACTCOMMAND	: String;				// -------o constructor					/**			* constructor function			* @public			* @return void			*/			public function FrakModel() : void {				_sABSTRACTCOMMAND = getQualifiedClassName(AbstractCommand);				_dCOMMANDS = new Dictionary(true);				_dVARS = new Dictionary(true);				_dVARS_CUSTOM = new Dictionary(true);				_dCOMMANDS_CUSTOM = new Dictionary(true);			}		// -------o public									/**			* initialize function			* Generic method, called first to initialize the model			* Registering the basics command who are native to the console			* 			* @public			* @param 	e	: optional init event (Event)			* @return	void			*/			final override public function initialize( e : Event = null ) : void {				Logger.getInstance().addEventListener(LoggerEvent.LOG_EVENT , _onLogEvent , false , 10 , true);				registerCommand('stack', 		StackCommand, 	'Stacking command',true);				registerCommand('test', 		test, 		'Test command',true);				registerCommand('exec', 		_execCommand, 	'Execute an command (example : exec org.shoebox.test.TestCommand)',true);				registerCommand('help', 		_help,		'obvious i think',true);				registerCommand('vlvl', 		_setLevel,		'Set the verbose level of the logger ( 1 - 4)',true);				registerCommand('vars', 		_varsList,		'Listing all the registered variables',true);				registerCommand('set', 			_setVarValue,	'Modify the value of an registered variable',true);				registerCommand('perf', 		_perf,		'Show / remove the performance module',true);				registerCommand('forcegc', 		_force,		'Force the garbage collector',true);				registerCommand('setfps', 		_setFps,		'Change the stage frameRate',true);			}			/**			* cancel function			* Generic method, called when the mvc application is destroyed			* @public			* @param 	e : optional event	(Event)			* @return	void			*/			final override public function cancel(e:Event = null) : void {				Logger.getInstance().removeEventListener(LoggerEvent.LOG_EVENT , _onLogEvent , false);				}						/**			* Register an command in to the console			* @public			* @param 	sCOMM	: Command name (without space in it of cource) (STRING)			* @return	void			*/			public function registerCommand( sCOMM:String , o : * , sHELP : String , b : Boolean = false ) : void {								if( b )					_dCOMMANDS[sCOMM]= Factory.build(FrakCommand , { name : sCOMM , callback : o , desc : sHELP });				else					_dCOMMANDS_CUSTOM[sCOMM]= Factory.build(FrakCommand , { name : sCOMM , callback : o , desc : sHELP });						}						/**			* Validation of the entered command in the input field			* @public			* @return void			*/			public function send() : void {				(view as FrakView).autoComplete( );				var sINPUT : String = (view as FrakView).command;								if(!sINPUT.match(/(?<name>[a-zA-Z0-9.]*)/)){					(view as FrakView).log('-Frak '+sINPUT+' syntax error !' , true);					return;				}				(view as FrakView).log( '\n'+sINPUT );				var sCOMMNAME:String = sINPUT.match(/(?<name>[a-zA-Z0-9.]*)/)[0];								// Testing if command exist					if( !_dCOMMANDS[sCOMMNAME] && !_dCOMMANDS_CUSTOM[sCOMMNAME]){						(view as FrakView).log('-Frak '+sCOMMNAME+' not found.<br>Verify your syntax or if the command is registered.' , true);						trace('command doest not exist');						return;					}								// Testing arguments					var aARGS:Array = sINPUT.split(' ');					var uLEN:uint = aARGS.length;					if(uLEN > 1)						aARGS = aARGS.slice( 1 , uLEN);					else						aARGS = [];												// Testing 										var oCOM : FrakCommand = _dCOMMANDS[sCOMMNAME] == null ? _dCOMMANDS_CUSTOM[sCOMMNAME] : _dCOMMANDS[sCOMMNAME];										var oCALLBACK : * = oCOM.callback;															//It's a command ?						if( getQualifiedSuperclassName( oCALLBACK ) == _sABSTRACTCOMMAND ){							(view as FrakView).log( '<font size="11">-Frak -Executing command '+sCOMMNAME+'</font>' , true);														var sARG:String;							var oARGS:Object = {};							var aTMP:Array;							for each( sARG in aARGS){								aTMP = sARG.split(':');								oARGS[aTMP[0]] = aTMP[1];							}														var 	oCOMM:AbstractCommand = Factory.build( oCALLBACK );								oCOMM.execute();															(view as FrakView).clear();							return;						}									//It's a function ?
					if( oCALLBACK is Function ) {						
						(view as FrakView).log('<font size="11">-Frak -Call function ' + sCOMMNAME + '</font>', true);							var oFUNC : Function = oCALLBACK;							if( uLEN > 1 )								oFUNC.apply(this,aARGS);							else								oFUNC.apply(this);						}									(view as FrakView).clear();			 }									/**			* Test function			* @public			* @param 	sTEST : Test variable (String)			* @return	void			*/			public function test(sTEST : String) : void {				(view as FrakView).log( '-Frak -Test function '+sTEST , true);			}						/**			* name function			* @public			* @param 			* @return			*/			public function registerVar( sVARNAME : String , tgt:* ) : void {				trc('registerVar ::: '+sVARNAME+' /// '+_dVARS);				_dVARS[sVARNAME] = { id:sVARNAME , target : tgt };			}						/**			* unRegisterVar function			* @public			* @param 			* @return			*/			final public function unRegisterVar( sVARNAME : String , tgt:* ) : void {				delete _dVARS[sVARNAME]; 			}						/**			* open function			* @public			* @param 			* @return			*/			final public function open() : void {				(view as FrakView).openclose();			}						/**			* log function			* @public			* @param 			* @return			*/			final public function log( s : String ) : void {				(view as FrakView).log( s );			}						/**
			* autoComplete function
			* @public
			* @param 
			* @return
			*/
			final public function autoComplete() : void {
				var s : String = (view as FrakView).tfIN.text;								var pattern:RegExp = new RegExp('^'+s); 								if( s === ''){					( view as FrakView).autoComplete( );					return;				}				var v : Vector.<String> = new Vector.<String>( );				var p : String;				for( p in _dCOMMANDS){										if( p.search( s ) == 0)						v.push( p );					
				}								for( p in _dCOMMANDS_CUSTOM ){										if( p.search( s ) == 0)						v.push( p.replace( pattern , '<b>'+s+'</b>') );				}								( view as FrakView).autoComplete( v );			}						/**
			* watch function
			* @public
			* @param 
			* @return
			*/
			final public function watch( s : String ) : void {
				(view as FrakView).watchString( s );
			}					// -------o protected						/**			* Listener function of any event from the logger class			* (@see Logger)			* @param	e : LoggerEvent  			* @return	void			*/			protected function _onLogEvent( e : LoggerEvent) : void {				if(e.errorLevel > 2 )					(view as FrakView).log(e.toString() , (e.errorLevel > 2));			}						/**			* Callback to execute commands			*			* @param 	sCOMMANDNAME : Name of the command (String)			* @return	void			*/			protected function _execCommand( sCOMMANDNAME : String , o : Object = null) : void {				(view as FrakView).log( '<i>-Frak -Execute command' + sCOMMANDNAME +'</i>', true);				Factory.build( sCOMMANDNAME , o ); 			}						/**			* Callback to set the verbose level of the logger			*			* @param  	u : Verbose level (uint)			* @return	void			*/			protected function _setLevel( u : uint ) : void {				(view as FrakView).log('-Frak -set verbose level :'+u);				Logger.level = u;			}						/**			* Help command 			* Trace all registered commands and their corresponds help text			* @return  void			*/			protected function _help() : void {								var 	sTMP:String = '<font size="11">-Frak -commands reference</font>\n';				var o:FrakCommand;								for each( o in _dCOMMANDS )					sTMP+= '<br>'+o.name + '\t\t\t\t - '+o.desc;					sTMP+= '\n\n<b>Registered custom commands</b>';									for each( o in _dCOMMANDS_CUSTOM )						sTMP+= '<br>'+o.name + '\t\t\t\t - '+o.desc;										(view as FrakView).log( sTMP+'\n' );											}						/**			* 			*			* @param 			* @return			*/			protected function _varsList() : void {				var sTMP:String = '-Frak registered variables list';				var o:*;				for each( o in _dVARS )					sTMP+=  '<br><b>'+ o.id + '</b>\t\t\t== '+o.target[o.id];					(view as FrakView).log( sTMP );								}						/**			* 			*			* @param 			* @return			*/			protected function _perf() : void {								if( _oPERF == null ){					_oPERF = new Perf();					_oPERF.y = ( view as FrakView ).HEIGHT;					view.addChild( _oPERF );					(view as FrakView).log( '-Frak -Perf module is active' , true);				}else{					view.removeChild( _oPERF );					_oPERF = null;					(view as FrakView).log( '-Frak -Perf module is now inactive' , true);				}			}						/**			* 			*			* @param 			* @return			*/			protected function _setVarValue( sVARNAME : String , oVALUE : * ) : void {								(view as FrakView).log('-Frak -setting value of the variable : '+sVARNAME+' to '+oVALUE,true);				if(_dVARS[sVARNAME]==null){					(view as FrakView).log('unknow variable');					return;				}								_dVARS[sVARNAME].target[_dVARS[sVARNAME].id] = oVALUE;			}			/**			* 			*			* @param 			* @return			*/			final protected function _force() : void {				(view as FrakView).log('-Frak -Force garbage collector');				if(!Capabilities.isDebugger)					(view as FrakView).log('Error : Only supported for debugger players');				else									System.gc();			}						/**			* 			*			* @param 			* @return			*/			final protected function _setFps( i : int = -1 ) : void {				(view as FrakView).stage.frameRate = i;			}					// -------o misc			public static function trc(arguments:*) : void {				//Logger.log(FrakModel,arguments);		}	}}import org.shoebox.utils.logger.Logger;/** * org.shoebox.apps.frakconsole.model.FrakModel	* @author shoebox	*/	internal class FrakCommand {				protected var _sDESC		:String;		protected var _sNAME		:String;		protected var _oCALLBACK	:*;				// -------o constructor					public function FrakCommand() : void {			}		// -------o public						/**			* Setter of the command code name			* @public			* @param	s : Command code name (String) 			* @return	void			*/			public function set name( s : String ) : void {				_sNAME = s;			}						/**			* Getter of the command code name			* @public			* @return	code name (String)			*/			public function get name() : String {				return _sNAME;			}						/**			* Callback setter 			* @public			* @param	o : Callback 			* 	The callback possible values are :                  *	<ul>                  * 		<li>AbstractCommand</li>                  * 		<li>Function</li>                  * 	</ul>				* @return void			*/			public function set callback( o : *) : void {				_oCALLBACK = o;			}			/**			* Callback getter			* 			* @public			* @return the callback (@see the setter)			*/			public function get callback() : * {				return _oCALLBACK;			}						/**				* Setter of the command description			* @public			* @param 	s : Command description (String)			* @return	void			*/			public function set desc( s : String ) : void {				_sDESC = s;			}						/**			* Getter of the command description			* @public			* @param 			* @return	s : Command description (String)			*/			public function get desc() : String {				return _sDESC;			}					// -------o protected		// -------o misc			public static function trc(arguments:*) : void {				Logger.log(FrakCommand,arguments);			}	}