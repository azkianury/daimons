package org.shoebox.patterns.commands {	import org.shoebox.utils.namespaces.SignalMode;	import org.shoebox.utils.namespaces.EventMode;	import org.shoebox.patterns.commands.events.CommandBatchProgressEvent;	import org.shoebox.patterns.commands.events.CommandEvents;	import org.shoebox.patterns.factory.Factory;	import org.shoebox.utils.logger.Logger;	import flash.events.Event;	/**	 * Execute a batch of commands via <code>AbstractCommand</code>	* 	* org.shoebox.patterns.commands.CommandBatch	* @date:29 sept. 09	* @author shoe[box]	*/	public class CommandBatch extends AbstractCommand implements ICommand{				[Event(name="PROGRESS", type="org.shoebox.patterns.commands.events.CommandBatchProgressEvent")]		[Event(name="COMMAND_COMPLETE", type="org.shoebox.patterns.commands.events.CommandBatchProgressEvent")]				internal var _oQUEUE			: Vector.<AbstractCommand>;		internal var _uINC			: uint;				protected var _oActual		: AbstractCommand;		protected var _uLEN			: uint;				// -------o constructor					/**			* Constructor of the class			* 			* @return void		 	*/			public function CommandBatch(ns : Namespace = EventMode) : void {				super( ns );				_oQUEUE = new Vector.<AbstractCommand>();			}					// -------o public						/**			* Getter of the comand instance			* 			* @public			* @return command instance (AbstractCommand)			*/			public function get command() : AbstractCommand {				return _oActual;			}						/**			* Add a command to the batch			* 			* @public			* @param	c : Command class to be added (Class)			* @param	o : Accessor init object	(Object) 			* @return 	void			*/			public function addCommand(c:Class , oAccessor : Object = null):void{				if( oAccessor )					oAccessor.batch = this;				else					oAccessor = { batch : this };									_oQUEUE.push(Factory.build(c,oAccessor) as AbstractCommand );			}						/**			* Override of the <code>onExecute</code> of the <code>AbstractCommand</code> class			* 			* @public			* @param	e : optional execute event	(Event) 			* @return 	void			*/			override final public function onExecute(e:Event = null):void{				_oActual = null;				_uINC = 0;				_uLEN = _oQUEUE.length;				_namespace :: _nextCommand();						}						/**			* When the command is canceled. 			* Override the <code>onCancel</code> of the <code>AbstractCommand</code> class  			* 			* @public			* @param	e : optional cancel event	(Event) 			* @return 	void			*/			override final public function onCancel(e:Event = null):void{				_oQUEUE = new Vector.<AbstractCommand>();			}						/**			* Clear the batch queue			* @public			* @param 			* @return			*/			final public function clear() : void {				stop( );				onComplete();			}						/**
			* stop function
			* @public
			* @param 
			* @return
			*/
			final public function stop() : void {
				_oQUEUE = new Vector.<AbstractCommand>();
			}						/**
			* get actual function
			* @public
			* @param 
			* @return
			*/
			final public function get actual() : AbstractCommand {
				return _oActual;
			}							// -------o private						/**			* Running the next command in the batch			* 			* @protected			* @param	e : optional command event	(CommandEvents) 			* @return 	void		 	*/			SignalMode function _nextCommand( c : AbstractCommand = null ) : void {								//					if( c ){						emit( CommandBatchProgressEvent.COMMAND_COMPLETE , _oActual, _uINC, _uLEN );					}									//					if( _oQUEUE.length == 0){												emit( CommandBatchProgressEvent.BATCH_COMPLETE , _oActual, _uINC, _uLEN );						_oActual = null;						onComplete();												return;					}									//					_oActual = _oQUEUE.shift() as AbstractCommand;					_oActual.connect( _namespace :: _nextCommand , CommandEvents.COMPLETE , 100 , true );					_oActual.execute();								//							if( hasEventListener( CommandBatchProgressEvent.PROGRESS ))								dispatchEvent( new CommandBatchProgressEvent( CommandBatchProgressEvent.PROGRESS , _oActual , _uINC , _uLEN));										_uINC++;							}						/**			* Running the next command in the batch			* 			* @protected			* @param	e : optional command event	(CommandEvents) 			* @return 	void		 	*/			EventMode function _nextCommand(e : CommandEvents = null) : void {							//Logger.warn(this,'nextCommand ::: '+e+' /// '+_oQUEUE.length);				//Logger.warn(this,'current command ::: '+_oActual);				//					if( e )						_oActual.removeEventListener(CommandEvents.COMPLETE , _namespace :: _nextCommand , false);								//					if ( _oActual) {												if( hasEventListener( CommandBatchProgressEvent.COMMAND_COMPLETE ))							dispatchEvent( new CommandBatchProgressEvent( CommandBatchProgressEvent.COMMAND_COMPLETE, _oActual, _uINC, _uLEN ) );											}									//					if(_oQUEUE.length==0){												if ( hasEventListener(CommandBatchProgressEvent.BATCH_COMPLETE))								dispatchEvent( new CommandBatchProgressEvent( CommandBatchProgressEvent.BATCH_COMPLETE, _oActual, _uINC, _uLEN ) );													_oActual = null;						onComplete();						return;					}													//					_oActual = _oQUEUE.shift() as AbstractCommand;					_oActual.addEventListener(CommandEvents.COMPLETE , _namespace :: _nextCommand , false , 100 , false);					_oActual.execute();								//							if( hasEventListener( CommandBatchProgressEvent.PROGRESS ))								dispatchEvent( new CommandBatchProgressEvent( CommandBatchProgressEvent.PROGRESS , _oActual , _uINC , _uLEN));										_uINC++;			}		// -------o misc			public static function trc(arguments:*) : void {				Logger.log(CommandBatch,arguments);			}	}}