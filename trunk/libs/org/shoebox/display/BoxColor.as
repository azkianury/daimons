package org.shoebox.display {	import org.shoebox.errors.Errors;	import org.shoebox.utils.logger.Logger;	import flash.errors.IllegalOperationError;	/**	 *	* org.shoebox.display.BoxColor	* @date:2 sept. 09	* @author shoe[box]	*/	public class BoxColor{		// -------o constructor			/**			* contructor			* @return void			*/			public function BoxColor():void{				Errors.throwError(new IllegalOperationError(Errors.STATICCLASSERROR));			}					// -------o public						/**			* 			* @param			* @return			*/			static public function getLuminance(uCOL:uint):Number{				return (299*(uCOL >>16 ) & 0xFF + 587*(uCOL >> 8 ) & 0xFF + 114*(uCOL & 0xFF));			}						/**			* Retrieve the distance between two colors			* @param	uCOL1		: Color 1	(UINT)			* @param	uCOL2		: Color 2	(UINT)			* @return	nDISTANCE	: Distance	(NUMBER)			*/			static public function colorDistance(uCOL1:uint , uCOL2:uint):Number{				var RGB1:RGBCol = HEXtoRGBOBJ( uCOL1 );				var RGB2:RGBCol = HEXtoRGBOBJ( uCOL2 );								var 	nDISTANCE:Number = 0;					nDISTANCE += Math.pow( RGB1.red - RGB2.red, 2 );					nDISTANCE += Math.pow( RGB1.green - RGB2.green, 2 );					nDISTANCE += Math.pow( RGB1.blue - RGB2.blue, 2 );								return nDISTANCE;							}						/**			* RGB to Hexadecimal conversion				* @param	nR : Red value	(NUMBER)			* @param	nG : Green value	(NUMBER)			* @param	nB : Blue value	(NUMBER)			* @return	hex color 		(UINT)			*/			static public function RGBtoHEX(nR:Number , nG:Number , nB:Number):uint{				return (nR << 16) + (nG << 8) + nB;								}						/**			* Hexadecimal to RGB conversion				* @param	uHEX : source color 	(UINT)				* @return	RGBCOL object 		(RGBCol)			*/			static public function HEXtoRGBOBJ(uHEX:uint):RGBCol{				return new RGBCol(uHEX >> 16 & 0xff, uHEX >> 8 & 0xff, uHEX & 0xff);				}						/**			* 			* @param			* @return			*/			static public function HEXContrast(uHEX:uint , nINC:Number):void{				var 	oCOL:RGBCol = HEXtoRGBOBJ(uHEX);					oCOL.red 	= minMAX( oCOL.red + nINC, 0, 255 );					oCOL.green 	= minMAX( oCOL.green + nINC, 0, 255 );					oCOL.blue 	= minMAX( oCOL.blue + nINC, 0, 255 );			}						/**			* Hexadecimal to matrix conversion			* @param	uHEX 	 : Color source	(UINT)			* @param	nALPHA : Color alpha 	(Number)			* @return	oMAT	 : Matrix result	(Array)			*/			static public function hexToMatrix(uHEX:uint , nALPHA:Number):Array{								var 	oMAT : Array = [];					oMAT = oMAT.concat([((uHEX & 0x00FF0000) >>> 16) / 255, 0, 0, 0, 0]);					oMAT = oMAT.concat([0, ((uHEX & 0x0000FF00) >>> 8) / 255, 0, 0, 0]); 					oMAT = oMAT.concat([0, 0, (uHEX & 0x000000FF) / 255, 0, 0]); 					oMAT = oMAT.concat([0, 0, 0, nALPHA / 100, 0]); 				return oMAT;							}					// -------o private						/**			* 			* @param			* @return			*/			static protected function minMAX(n:Number , nMIN:Number , nMAX:Number):Number{				n = Math.max(n,nMIN);				n = Math.min(n,nMAX);				return n;			}					// -------o misc			public static function trc(arguments:*) : void {				Logger.log(BoxColor,arguments);			}	}}//	class RGBCol extends Object{				protected var _nR		:Number;		protected var _nG		:Number;		protected var _nB		:Number;				// -------o constructor			public function RGBCol(nR:Number , nG:Number , nB:Number){				_nR = nR;				_nG = nG;				_nB = nB;			}					// -------o public						/**			* 			* @param			* @return			*/			public function get red():Number{				return _nR;			}						/**			* 			* @param			* @return			*/			public function set red(n:Number):void{				_nR = n;			}						/**			* 			* @param			* @return			*/			public function get blue():Number{				return _nB;			}						/**			* 			* @param			* @return			*/			public function set blue(n:Number):void{				_nB = n;			}						/**			* 			* @param			* @return			*/			public function get green():Number{				return _nG;			}						/**			* 			* @param			* @return			*/			public function set green(n:Number):void{				_nG = n;			}	}