package org.shoebox.patterns.commands {	import org.shoebox.errors.Errors;	import org.shoebox.patterns.commands.events.CommandEvents;	import org.shoebox.patterns.frontcontroller.FrontController;	import org.shoebox.utils.DescribeTypeCache;	import org.shoebox.utils.namespaces.EventMode;	import org.shoebox.utils.namespaces.SignalMode;	import org.shoebox.utils.system.Signal;	import flash.errors.IllegalOperationError;	import flash.events.Event;		/**	 *	* org.shoebox.patterns.commands.AbstractCommand	* @date:2 sept. 09	* @author shoe[box]	*/	public class AbstractCommand extends Signal implements ICommand{				[Event(name="Event_COMMAND_COMPLETE", 	type="org.shoebox.patterns.commands.events.CommandEvents")]		[Event(name="Event_COMMAND_CANCEL",	 	type="org.shoebox.patterns.commands.events.CommandEvents")]		[Event(name="Event_COMMAND_START", 		type="org.shoebox.patterns.commands.events.CommandEvents")]				public var frontController			: FrontController = null;				protected var _namespace 			: Namespace = EventMode;				protected const ERROR_ISRUNNING		: String = 'Execute() failed. Command is already running';		protected const ERROR_ISCANCELED		: String = 'Execute() failed. Command is canceled';				protected var _oComBatch			: CommandBatch = null;		protected var _bIsCancelable			: Boolean = true;		protected var _bIsRunning			: Boolean = false;		protected var _bIsCanceled			: Boolean = false;				// -------o constructor					/**			* contructor			* @return void		 	*/			public function AbstractCommand( ns : Namespace = EventMode ) : void {				_namespace = ns;			}					// -------o public						/**			* set cancelable function			* @public			* @param 			* @return			*/			public function set cancelable( b : Boolean ) : void {				_bIsCancelable = b;			}						/**			* 			*			* @param 			* @return			*/			public function execute(e:Event = null) : void {								if( _bIsRunning )					throw new IllegalOperationError(ERROR_ISRUNNING+' /// '+DescribeTypeCache.getDesc(this).@name) ;				else if( _bIsCanceled )					throw new IllegalOperationError(ERROR_ISCANCELED+' /// '+DescribeTypeCache.getDesc(this).@name) ;				else{					trc( '/!\\  '+DescribeTypeCache.getDesc(this).@name+' COMMAND IS NOW RUNNING </!\\>' );					start();					_bIsCanceled = false;					_bIsRunning = true;					onExecute(e);				}			}						/**			* start function			* @public			* @param 			* @return			*/			public function start() : void {				_bIsRunning = true;				dispatchEvent( new CommandEvents( CommandEvents.START ));			}			/**			* 			*			* @param 			* @return			*/			public function cancel(e:Event = null) : void {								if(_bIsCanceled)					throw(  new IllegalOperationError('The command is already canceled'));									if(!_bIsRunning)					throw( new IllegalOperationError('Cannot cancel a command who was not started'));												//trc('/!\\  '+DescribeTypeCache.getDesc(this).@name+' COMMAND IS NOW CANCELED </!\\>');								if(_bIsCancelable)					_bIsCanceled = true;					_bIsRunning = false;									onCancel(e);				}						/**			* get isRunning function			* @public			* @param 			* @return			*/			final public function get isRunning() : Boolean {				return _bIsRunning;			}						/**			* 			* @param			* @return			*/			public function onExecute(e:Event = null):void{				throw(new Error(Errors.IMPLEMENTATIONERROR));						}						/**			* 			* @param			* @return			*/			public function onCancel(e:Event = null):void{				throw(new Error(Errors.IMPLEMENTATIONERROR));				}						/**			* onComplete function			* @public			* 			* @param	o : Optional argument (Object) 			* @return void			*/			public function onComplete( ):void{								if ( _namespace == null )					_namespace = SignalMode;				SignalMode :: _onCompleted( );			}						/**			* set batch function			* @public			* @param 			* @return			*/			final public function set batch( o : CommandBatch ) : void {				_oComBatch = o;			}						/**			* get batch function			* @public			* @param 			* @return			*/			final public function get batch() : CommandBatch {				return _oComBatch;			}		// -------o private						/**			* 			*			* @param 			* @return		 	*/			SignalMode function _onCompleted() : void {							emit( CommandEvents.COMPLETE , this );				_bIsRunning = false;							}						/**
			* 
			*
			* @param 
			* @return			*/			EventMode function _onCompleted() : void {				dispatchEvent(new CommandEvents(CommandEvents.COMPLETE));				_bIsRunning = false;
			}					// -------o misc			public static function trc(arguments:*) : void {				//Logger.log(AbstractCommand,arguments);			}	}}